# Speck Orchestrator End-to-End Test
#
# ONLY RUNS IN telum-ai/speck REPOSITORY
# Tests the REAL orchestrator workflow by triggering it against test fixtures.
#
# Flow:
# 1. Trigger speck-orchestrator.yml with test_mode=true and specs_root=tests/fixtures/...
# 2. Wait for the orchestrator to complete
# 3. Verify issues were created with test:e2e label
# 4. Verify Copilot was assigned (if token available)
# 5. Clean up all test issues and branches

name: Orchestrator E2E Test

on:
  push:
    paths:
      - '.github/workflows/speck-orchestrator.yml'
      - '.github/workflows/speck-orchestrator-e2e-test.yml'
      - '.speck/scripts/orchestrate.sh'
      - 'tests/fixtures/orchestrator-test/**'
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

jobs:
  e2e-test:
    # CRITICAL: Only run in the Speck template repository
    if: github.repository == 'telum-ai/speck'
    runs-on: ubuntu-latest
    timeout-minutes: 25
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Verify test environment
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ ! -d "tests/fixtures/orchestrator-test" ]; then
            echo "ERROR: Test fixtures not found"
            exit 1
          fi
          
          # Ensure test:e2e label exists
          gh label create "test:e2e" \
            --description "End-to-end integration test" \
            --color "E99695" \
            --force \
            --repo "${{ github.repository }}" || true
          
          echo "âœ“ E2E test environment ready"
      
      - name: Pick random test story
        id: pick_story
        run: |
          # Pick ONE random story for testing
          CANDIDATES=(
            "S001-project-setup"
            "S002-express-config"
            "S003-greeting-service"
            "S004-greeting-endpoint"
            "S008-performance-test"
          )
          
          RANDOM_INDEX=$((RANDOM % ${#CANDIDATES[@]}))
          STORY="${CANDIDATES[$RANDOM_INDEX]}"
          
          echo "story_id=$STORY" >> $GITHUB_OUTPUT
          echo "ðŸŽ² Randomly selected: $STORY"
      
      - name: Trigger real orchestrator workflow
        id: trigger
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          STORY_ID: ${{ steps.pick_story.outputs.story_id }}
        run: |
          echo "ðŸš€ Triggering orchestrator for SINGLE story: $STORY_ID"
          
          # Trigger with SINGLE_STORY filter - only creates ONE issue
          gh workflow run speck-orchestrator.yml \
            --repo "$REPO" \
            -f specs_root="tests/fixtures/orchestrator-test/specs" \
            -f single_story="$STORY_ID" \
            -f test_mode=true
          
          # Wait a bit for the run to be created
          sleep 10
          
          # Get the run ID
          RUN_ID=$(gh run list \
            --repo "$REPO" \
            --workflow "Speck Orchestrator" \
            --limit 1 \
            --json databaseId \
            --jq '.[0].databaseId')
          
          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
          echo "ðŸ“‹ Started orchestrator run: $RUN_ID (single story: $STORY_ID)"
      
      - name: Wait for orchestrator to complete
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RUN_ID: ${{ steps.trigger.outputs.run_id }}
          REPO: ${{ github.repository }}
        run: |
          echo "â³ Waiting for orchestrator run $RUN_ID to complete..."
          
          MAX_WAIT=300  # 5 minutes
          ELAPSED=0
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            STATUS=$(gh run view "$RUN_ID" --repo "$REPO" --json status,conclusion --jq '.status')
            CONCLUSION=$(gh run view "$RUN_ID" --repo "$REPO" --json conclusion --jq '.conclusion')
            
            echo "  Status: $STATUS (conclusion: $CONCLUSION)"
            
            if [ "$STATUS" = "completed" ]; then
              if [ "$CONCLUSION" = "success" ]; then
                echo "âœ… Orchestrator completed successfully!"
                exit 0
              else
                echo "âš ï¸  Orchestrator completed with: $CONCLUSION"
                # Continue anyway to verify what was created
                exit 0
              fi
            fi
            
            sleep 15
            ELAPSED=$((ELAPSED + 15))
          done
          
          echo "âš ï¸  Timeout waiting for orchestrator"
      
      - name: Verify single issue created
        id: verify
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          STORY_ID: ${{ steps.pick_story.outputs.story_id }}
        run: |
          echo "ðŸ” Checking for test issue (expecting exactly 1)..."
          
          # Get issues with test:e2e label
          ISSUES=$(gh issue list --repo "$REPO" --label "test:e2e" --state open --json number,title,labels --jq '.')
          COUNT=$(echo "$ISSUES" | jq 'length')
          
          echo "issues_created=$COUNT" >> $GITHUB_OUTPUT
          echo "ðŸ“ Found $COUNT test issue(s)"
          
          if [ "$COUNT" -eq 0 ]; then
            echo "âŒ No test issue created!"
            exit 1
          fi
          
          if [ "$COUNT" -gt 1 ]; then
            echo "âš ï¸  WARNING: Expected 1 issue, found $COUNT!"
            echo "Single story filter may not be working correctly."
          fi
          
          # Show the issue
          echo "$ISSUES" | jq -r '.[] | "  - #\(.number): \(.title)"'
          
          # Get issue number for cleanup
          ISSUE_NUM=$(echo "$ISSUES" | jq -r '.[0].number')
          echo "issue_number=$ISSUE_NUM" >> $GITHUB_OUTPUT
          
          echo "âœ… Test issue created for story: $STORY_ID"
      
      - name: Monitor Copilot assignment
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          HAS_COPILOT_TOKEN: ${{ secrets.COPILOT_ASSIGNMENT_TOKEN != '' }}
        timeout-minutes: 10
        run: |
          if [ "$HAS_COPILOT_TOKEN" != "true" ]; then
            echo "âš ï¸  COPILOT_ASSIGNMENT_TOKEN not set - skipping Copilot monitoring"
            exit 0
          fi
          
          echo "â±ï¸  Monitoring for Copilot activity (up to 10 min)..."
          
          MAX_WAIT=600
          ELAPSED=0
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            # Check for in-progress issues
            IN_PROGRESS=$(gh issue list --repo "$REPO" --label "test:e2e,speck:in-progress" --json number --jq 'length')
            
            if [ "$IN_PROGRESS" -gt 0 ]; then
              echo "âœ… Copilot is working! ($IN_PROGRESS issues in progress)"
              break
            fi
            
            # Check for PRs
            PRs=$(gh pr list --repo "$REPO" --label "test:e2e" --json number --jq 'length' 2>/dev/null || echo "0")
            if [ "$PRs" -gt 0 ]; then
              echo "âœ… Copilot created PRs!"
              break
            fi
            
            echo "â³ Waiting... ($ELAPSED/$MAX_WAIT seconds)"
            sleep 30
            ELAPSED=$((ELAPSED + 30))
          done
      
      - name: Cleanup test artifacts
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
        run: |
          echo "ðŸ§¹ Cleaning up test artifacts..."
          
          # Get all test issues
          ISSUE_NUMS=$(gh issue list --repo "$REPO" --label "test:e2e" --state all --json number --jq '.[].number' 2>/dev/null || true)
          
          for ISSUE_NUM in $ISSUE_NUMS; do
            echo "  Closing issue #$ISSUE_NUM"
            gh issue close "$ISSUE_NUM" --repo "$REPO" --reason "not planned" --comment "ðŸ§¹ E2E test cleanup" 2>/dev/null || true
          done
          
          # Close any test PRs
          PR_NUMS=$(gh pr list --repo "$REPO" --label "test:e2e" --state open --json number --jq '.[].number' 2>/dev/null || true)
          
          for PR_NUM in $PR_NUMS; do
            echo "  Closing PR #$PR_NUM"
            gh pr close "$PR_NUM" --repo "$REPO" --comment "ðŸ§¹ E2E test cleanup" 2>/dev/null || true
            
            BRANCH=$(gh pr view "$PR_NUM" --repo "$REPO" --json headRefName --jq '.headRefName' 2>/dev/null || true)
            if [[ "$BRANCH" == copilot/* ]]; then
              echo "  Deleting branch: $BRANCH"
              git push origin --delete "$BRANCH" 2>/dev/null || true
            fi
          done
          
          echo "âœ… Cleanup complete"
      
      - name: Report results
        if: always()
        env:
          STORY_ID: ${{ steps.pick_story.outputs.story_id }}
          ISSUE_NUM: ${{ steps.verify.outputs.issue_number }}
          RUN_ID: ${{ steps.trigger.outputs.run_id }}
        run: |
          echo "## ðŸ§ª E2E Test Results"
          echo ""
          echo "| Metric | Value |"
          echo "|--------|-------|"
          echo "| Story Tested | $STORY_ID |"
          echo "| Issue Created | #$ISSUE_NUM |"
          echo "| Orchestrator Run | $RUN_ID |"
          echo ""
          echo "This test verified that the **real orchestrator** can:"
          echo "1. âœ… Process a SINGLE story from test fixtures"
          echo "2. âœ… Create exactly ONE issue with proper labels"
          echo "3. âœ… Route the story to correct command"
          echo ""
          echo "All test artifacts have been cleaned up."
