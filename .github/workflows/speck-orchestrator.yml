# Speck Orchestrator
#
# Continuous orchestration of story work. Creates issues and assigns to Copilot.
# Drives stories through the ENTIRE Speck flow up to and including story-validate.
#
# SCOPE: All commands from story-specify through story-validate
# COMPLETION: Story is complete when validation-report.md exists with PASS status

name: Speck Orchestrator

on:
  # Continuous orchestration - check every 15 minutes
  schedule:
    - cron: '*/15 * * * *'
  
  # Trigger on spec changes
  push:
    paths:
      - 'specs/**/epic-breakdown.md'
      - 'specs/**/stories/**'
    branches:
      - main
      - develop
  
  # Manual trigger
  workflow_dispatch:
    inputs:
      epic_path:
        description: 'Epic path (or leave empty to scan all)'
        required: false
        type: string
  
  # Re-orchestrate after PR merges (unblock dependents, continue validation)
  pull_request:
    types: [closed]
    branches:
      - main
      - develop

permissions:
  contents: read
  issues: write
  pull-requests: read

env:
  MAX_CONCURRENT_COPILOT: 3

jobs:
  ensure-labels:
    runs-on: ubuntu-latest
    steps:
      - name: Create Speck labels if missing
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
        run: |
          gh label create "speck:story" --color "0E8A16" --description "Speck story" --force --repo "$GH_REPO" || true
          gh label create "speck:blocked" --color "B60205" --description "Blocked by dependencies" --force --repo "$GH_REPO" || true
          gh label create "speck:queued" --color "C5DEF5" --description "Queued for Copilot" --force --repo "$GH_REPO" || true
          gh label create "speck:in-progress" --color "FBCA04" --description "Copilot working" --force --repo "$GH_REPO" || true
          gh label create "speck:validated" --color "0E8A16" --description "Story validated" --force --repo "$GH_REPO" || true
          gh label create "automated" --color "BFD4F2" --description "Created by automation" --force --repo "$GH_REPO" || true

  orchestrate:
    needs: ensure-labels
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Extract template instructions
        run: |
          TEMPLATE_FILE=".github/ISSUE_TEMPLATE/speck-story.yml"
          if [ -f "$TEMPLATE_FILE" ]; then
            sed -n '/value: |/,/^[^ ]/p' "$TEMPLATE_FILE" | tail -n +2 | head -n -1 | sed 's/^        //' > /tmp/template_instructions.md
          else
            echo "See .github/ISSUE_TEMPLATE/speck-story.yml for command flow." > /tmp/template_instructions.md
          fi
      
      - name: Find stories and create/update issues
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          EPIC_PATH: ${{ inputs.epic_path || '' }}
          REPO: ${{ github.repository }}
        run: |
          if [ -n "$EPIC_PATH" ]; then
            EPICS="$EPIC_PATH"
          else
            EPICS=$(find specs -name "epic-breakdown.md" -exec dirname {} \; 2>/dev/null | sort -t/ -k6 -V || true)
          fi
          
          MERGED_PRS=$(gh pr list --repo "$REPO" --state merged --limit 100 --json title --jq '.[].title' 2>/dev/null || true)
          
          for EPIC_DIR in $EPICS; do
            echo "Processing epic: $EPIC_DIR"
            
            EPIC_ID=$(basename "$EPIC_DIR")
            EPIC_NAME=$(grep -m1 "^# " "$EPIC_DIR/epic.md" 2>/dev/null | sed 's/^# //' || echo "$EPIC_ID")
            EPIC_CONTEXT=$(sed -n '/^## Overview/,/^##/p' "$EPIC_DIR/epic.md" 2>/dev/null | head -10 | tail -9 || echo "See epic.md for details")
            
            PLANNED_STORIES=""
            if [ -f "$EPIC_DIR/epic-breakdown.md" ]; then
              PLANNED_STORIES=$(grep -oE '(S[0-9]{3}|story-[0-9]{3})' "$EPIC_DIR/epic-breakdown.md" 2>/dev/null | sort -u | tr '\n' ' ' || true)
            fi
            
            STORIES_DIR="$EPIC_DIR/stories"
            mkdir -p "$STORIES_DIR" 2>/dev/null || true
            
            ALL_STORIES=""
            for STORY_ID in $PLANNED_STORIES; do
              if [[ "$STORY_ID" =~ ^S([0-9]{3})$ ]]; then
                FULL_DIR=$(ls -d "$STORIES_DIR/$STORY_ID"-* 2>/dev/null | head -1 || echo "")
                if [ -n "$FULL_DIR" ]; then
                  STORY_ID=$(basename "$FULL_DIR")
                fi
              fi
              ALL_STORIES="$ALL_STORIES $STORY_ID"
            done
            
            for STORY_DIR in $(ls -d "$STORIES_DIR"/*/ 2>/dev/null); do
              ALL_STORIES="$ALL_STORIES $(basename "$STORY_DIR")"
            done
            
            ALL_STORIES=$(echo "$ALL_STORIES" | tr ' ' '\n' | grep -v '^$' | sort -u -V | tr '\n' ' ')
            
            for STORY_ID in $ALL_STORIES; do
              [ -z "$STORY_ID" ] && continue
              
              STORY_DIR="$STORIES_DIR/$STORY_ID"
              
              # Skip ONLY if validation-report.md exists with PASS status
              if [ -d "$STORY_DIR" ] && [ -f "$STORY_DIR/validation-report.md" ]; then
                if grep -q "Status.*PASS" "$STORY_DIR/validation-report.md" 2>/dev/null; then
                  echo "  Skipping $STORY_ID (validated)"
                  continue
                fi
              fi
              
              # Skip if issue already exists and is in progress
              EXISTING_ISSUE=$(gh issue list --repo "$REPO" --label "speck:story" --search "in:title $STORY_ID" --state open --json number,labels --jq '.[0]' 2>/dev/null || echo "")
              if [ -n "$EXISTING_ISSUE" ] && [ "$EXISTING_ISSUE" != "null" ]; then
                ISSUE_NUM=$(echo "$EXISTING_ISSUE" | jq -r '.number')
                IS_IN_PROGRESS=$(echo "$EXISTING_ISSUE" | jq -r '.labels | map(.name) | any(. == "speck:in-progress")')
                if [ "$IS_IN_PROGRESS" = "true" ]; then
                  echo "  Skipping $STORY_ID (issue #$ISSUE_NUM in progress)"
                  continue
                fi
              fi
              
              # Determine current phase based on existing files
              CURRENT_PHASE="unspecced"
              START_CMD="story-specify"
              
              if [ -d "$STORY_DIR" ]; then
                if [ -f "$STORY_DIR/validation-report.md" ]; then
                  # Validation exists but didn't pass - need to re-validate or fix
                  CURRENT_PHASE="implemented"
                  START_CMD="story-validate"
                elif [ -f "$STORY_DIR/tasks.md" ]; then
                  # Check if implementation has started by looking for:
                  # 1. A PR (open or merged) that mentions this story
                  # 2. analysis-report.md exists (story-analyze was run)
                  HAS_PR=$(gh pr list --repo "$REPO" --state all --search "$STORY_ID in:title" --json number --jq 'length' 2>/dev/null || echo "0")
                  if [ "$HAS_PR" -gt 0 ]; then
                    CURRENT_PHASE="implemented"
                    START_CMD="story-validate"
                  elif [ -f "$STORY_DIR/analysis-report.md" ]; then
                    CURRENT_PHASE="analyzed"
                    START_CMD="story-implement"
                  else
                    CURRENT_PHASE="tasked"
                    START_CMD="story-analyze"
                  fi
                elif [ -f "$STORY_DIR/plan.md" ]; then
                  CURRENT_PHASE="planned"
                  START_CMD="story-tasks"
                elif [ -f "$STORY_DIR/spec.md" ]; then
                  if grep -q "## Acceptance Criteria" "$STORY_DIR/spec.md" 2>/dev/null; then
                    CURRENT_PHASE="clarified"
                    START_CMD="story-plan"
                  else
                    CURRENT_PHASE="specified"
                    START_CMD="story-clarify"
                  fi
                fi
              fi
              
              # Get story title
              TITLE=""
              if [ -f "$STORY_DIR/spec.md" ]; then
                TITLE=$(grep -m1 "^# " "$STORY_DIR/spec.md" 2>/dev/null | sed 's/^# //' || echo "")
              fi
              if [ -z "$TITLE" ]; then
                if [[ "$STORY_ID" =~ ^[Ss][0-9]{3}-(.+)$ ]]; then
                  TITLE=$(echo "${BASH_REMATCH[1]}" | tr '-' ' ' | sed 's/\b\(.\)/\u\1/g')
                else
                  TITLE="(needs spec)"
                fi
              fi
              
              # Check dependencies
              BLOCKED=false
              BLOCKING=""
              if [ -f "$STORY_DIR/tasks.md" ]; then
                DEPS=$(sed -n '/^---$/,/^---$/p' "$STORY_DIR/tasks.md" | grep "depends_on:" | sed 's/depends_on://' | tr -d '[],' || true)
                for DEP in $DEPS; do
                  DEP=$(echo "$DEP" | tr -d ' "')
                  [ -z "$DEP" ] && continue
                  # Check if dependency is validated (not just merged)
                  DEP_DIR=$(find specs -type d -name "*$DEP*" 2>/dev/null | head -1)
                  if [ -z "$DEP_DIR" ] || [ ! -f "$DEP_DIR/validation-report.md" ]; then
                    BLOCKED=true
                    BLOCKING="$BLOCKING $DEP"
                  elif ! grep -q "Status.*PASS" "$DEP_DIR/validation-report.md" 2>/dev/null; then
                    BLOCKED=true
                    BLOCKING="$BLOCKING $DEP"
                  fi
                done
              fi
              
              # Build issue body (avoid heredoc with special YAML chars)
              {
                echo "## Story Details"
                echo ""
                echo "| Field | Value |"
                echo "|-------|-------|"
                echo "| **Epic** | $EPIC_ID |"
                echo "| **Story** | $STORY_ID |"
                echo "| **Title** | $TITLE |"
                echo "| **Phase** | $CURRENT_PHASE |"
                echo "| **Start Command** | \`$START_CMD\` |"
                echo ""
                echo "### Epic Context"
                echo ""
                echo "$EPIC_CONTEXT"
                echo ""
              } > /tmp/issue_body.md

              cat /tmp/template_instructions.md >> /tmp/issue_body.md

              if [ "$BLOCKED" = true ]; then
                {
                  echo ""
                  echo "---"
                  echo "⚠️ **BLOCKED** - Waiting for validated:$BLOCKING"
                  echo ""
                  echo "Do not start until dependencies are validated (have PASS in validation-report.md)."
                } >> /tmp/issue_body.md
              fi
              
              # Set labels
              if [ "$BLOCKED" = true ]; then
                LABEL="speck:story,automated,speck:blocked"
              else
                LABEL="speck:story,automated,speck:queued"
              fi
              
              # Create or update issue
              if [ -n "$EXISTING_ISSUE" ] && [ "$EXISTING_ISSUE" != "null" ]; then
                ISSUE_NUM=$(echo "$EXISTING_ISSUE" | jq -r '.number')
                echo "  Updating issue #$ISSUE_NUM for $STORY_ID ($CURRENT_PHASE -> $START_CMD)"
                gh issue edit "$ISSUE_NUM" --repo "$REPO" --body-file /tmp/issue_body.md
                # Re-queue if it was blocked but now unblocked
                if [ "$BLOCKED" = false ]; then
                  gh issue edit "$ISSUE_NUM" --repo "$REPO" --remove-label "speck:blocked" --add-label "speck:queued" 2>/dev/null || true
                fi
              else
                gh issue create \
                  --repo "$REPO" \
                  --title "[$EPIC_ID] $STORY_ID: $TITLE" \
                  --body-file /tmp/issue_body.md \
                  --label "$LABEL"
                echo "  Created: $STORY_ID ($CURRENT_PHASE -> $START_CMD) [$([ "$BLOCKED" = true ] && echo 'BLOCKED' || echo 'QUEUED')]"
              fi
            done
          done

  unblock-dependents:
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Unblock dependent stories
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          REPO: ${{ github.repository }}
        run: |
          STORY_NAME=$(echo "$PR_TITLE" | grep -oE 'S[0-9]{3}[^ ]*' | head -1 || echo "")
          [ -z "$STORY_NAME" ] && exit 0
          
          echo "Story merged: $STORY_NAME"
          
          # Check if the merged story now has a passing validation
          STORY_DIR=$(find specs -type d -name "*$STORY_NAME*" 2>/dev/null | head -1)
          if [ -z "$STORY_DIR" ] || [ ! -f "$STORY_DIR/validation-report.md" ]; then
            echo "Story not yet validated, dependents remain blocked"
            exit 0
          fi
          
          if ! grep -q "Status.*PASS" "$STORY_DIR/validation-report.md" 2>/dev/null; then
            echo "Story validation not PASS, dependents remain blocked"
            exit 0
          fi
          
          echo "Story validated with PASS, unblocking dependents"
          
          BLOCKED_ISSUES=$(gh issue list --repo "$REPO" --label "speck:blocked" --json number,body --jq '.[] | @base64' 2>/dev/null || true)
          
          for ISSUE_B64 in $BLOCKED_ISSUES; do
            ISSUE=$(echo "$ISSUE_B64" | base64 -d)
            ISSUE_NUM=$(echo "$ISSUE" | jq -r '.number')
            ISSUE_BODY=$(echo "$ISSUE" | jq -r '.body')
            
            if echo "$ISSUE_BODY" | grep -q "$STORY_NAME"; then
              echo "Unblocking issue #$ISSUE_NUM"
              gh issue edit "$ISSUE_NUM" --repo "$REPO" --remove-label "speck:blocked" --add-label "speck:queued"
              gh issue comment "$ISSUE_NUM" --repo "$REPO" --body "✅ Dependency **$STORY_NAME** validated! This story is now queued."
            fi
          done

  assign-copilot:
    needs: [ensure-labels, orchestrate]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Assign queued stories (rate limited)
        env:
          GH_TOKEN: ${{ secrets.COPILOT_ASSIGNMENT_TOKEN || secrets.GITHUB_TOKEN }}
          MAX_CONCURRENT: ${{ env.MAX_CONCURRENT_COPILOT }}
          REPO: ${{ github.repository }}
        run: |
          if [ -z "${{ secrets.COPILOT_ASSIGNMENT_TOKEN }}" ]; then
            echo "⚠️  WARNING: COPILOT_ASSIGNMENT_TOKEN not set!"
            echo "The default GITHUB_TOKEN cannot assign copilot-swe-agent[bot]."
            echo "Please create a PAT with 'repo' scope and add it as COPILOT_ASSIGNMENT_TOKEN secret."
            echo "See: .speck/README.md → Autonomous Development → Setup"
            exit 1
          fi
          
          IN_PROGRESS=$(gh issue list --repo "$REPO" --label "speck:in-progress" --json number --jq 'length' 2>/dev/null || echo "0")
          echo "In progress: $IN_PROGRESS / $MAX_CONCURRENT"
          
          AVAILABLE=$((MAX_CONCURRENT - IN_PROGRESS))
          [ "$AVAILABLE" -le 0 ] && { echo "Rate limit reached"; exit 0; }
          
          QUEUED=$(gh issue list --repo "$REPO" --label "speck:queued" --json number --jq 'sort_by(.number) | .[].number' | head -n "$AVAILABLE")
          
          for ISSUE_NUM in $QUEUED; do
            echo "Assigning Copilot to #$ISSUE_NUM"
            
            PAYLOAD=$(cat <<'EOFPAYLOAD'
          {
            "assignees": ["copilot-swe-agent[bot]"],
            "agent_assignment": {
              "target_repo": "REPO_PLACEHOLDER",
              "base_branch": "main",
              "custom_instructions": "",
              "custom_agent": "",
              "model": ""
            }
          }
          EOFPAYLOAD
          )
            
            PAYLOAD=$(echo "$PAYLOAD" | sed "s|REPO_PLACEHOLDER|$REPO|g")
            
            echo "$PAYLOAD" | gh api \
              --method POST \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/repos/$REPO/issues/$ISSUE_NUM/assignees" \
              --input -
            
            gh issue edit "$ISSUE_NUM" --repo "$REPO" --remove-label "speck:queued" --add-label "speck:in-progress"
            
            echo "  ✓ Copilot assigned to #$ISSUE_NUM"
          done

  mark-validated:
    needs: [ensure-labels, orchestrate]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Mark validated stories complete
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
        run: |
          # Find all in-progress issues and check if they're now validated
          IN_PROGRESS=$(gh issue list --repo "$REPO" --label "speck:in-progress" --json number,title --jq '.[] | @base64' 2>/dev/null || true)
          
          for ISSUE_B64 in $IN_PROGRESS; do
            ISSUE=$(echo "$ISSUE_B64" | base64 -d)
            ISSUE_NUM=$(echo "$ISSUE" | jq -r '.number')
            ISSUE_TITLE=$(echo "$ISSUE" | jq -r '.title')
            
            STORY_ID=$(echo "$ISSUE_TITLE" | grep -oE 'S[0-9]{3}[^ :]*' | head -1 || echo "")
            [ -z "$STORY_ID" ] && continue
            
            STORY_DIR=$(find specs -type d -name "*$STORY_ID*" 2>/dev/null | head -1)
            [ -z "$STORY_DIR" ] && continue
            
            if [ -f "$STORY_DIR/validation-report.md" ]; then
              if grep -q "Status.*PASS" "$STORY_DIR/validation-report.md" 2>/dev/null; then
                echo "Story $STORY_ID validated! Closing issue #$ISSUE_NUM"
                gh issue edit "$ISSUE_NUM" --repo "$REPO" --remove-label "speck:in-progress" --add-label "speck:validated"
                gh issue close "$ISSUE_NUM" --repo "$REPO" --reason completed --comment "✅ Story validated successfully! See \`$STORY_DIR/validation-report.md\`"
              fi
            fi
          done
