# Speck Orchestrator
#
# Creates issues for stories and assigns to Copilot (respecting rate limits).
# Manages dependencies between stories.
#
# SCOPE: Commands up to story-implement (creates PR)
# HANDOFF: speck-validate-pr.yml handles validation, speck-retrospective.yml handles retro

name: Speck Orchestrator

on:
  push:
    paths:
      - 'specs/**/epic-breakdown.md'
      - 'specs/**/stories/**'
    branches:
      - main
      - develop
  
  workflow_dispatch:
    inputs:
      epic_path:
        description: 'Epic path (or leave empty to scan all)'
        required: false
        type: string
  
  pull_request:
    types: [closed]
    branches:
      - main
      - develop

permissions:
  contents: read
  issues: write
  pull-requests: read

env:
  MAX_CONCURRENT_COPILOT: 3

jobs:
  ensure-labels:
    runs-on: ubuntu-latest
    steps:
      - name: Create Speck labels if missing
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
        run: |
          gh label create "speck:story" --color "0E8A16" --description "Speck story" --force --repo "$GH_REPO" || true
          gh label create "speck:blocked" --color "B60205" --description "Blocked by dependencies" --force --repo "$GH_REPO" || true
          gh label create "speck:queued" --color "C5DEF5" --description "Queued for Copilot" --force --repo "$GH_REPO" || true
          gh label create "speck:in-progress" --color "FBCA04" --description "Copilot working" --force --repo "$GH_REPO" || true
          gh label create "automated" --color "BFD4F2" --description "Created by automation" --force --repo "$GH_REPO" || true

  orchestrate:
    needs: ensure-labels
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Find stories and create issues
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          EPIC_PATH: ${{ inputs.epic_path || '' }}
        run: |
          if [ -n "$EPIC_PATH" ]; then
            EPICS="$EPIC_PATH"
          else
            # Sort epics by numeric ID (E000, E001, E002...)
            EPICS=$(find specs -name "epic-breakdown.md" -exec dirname {} \; 2>/dev/null | sort -t/ -k6 -V || true)
          fi
          
          MERGED_PRS=$(gh pr list --state merged --limit 100 --json title --jq '.[].title' 2>/dev/null || true)
          
          for EPIC_DIR in $EPICS; do
            echo "Processing epic: $EPIC_DIR"
            
            # Extract planned stories from epic-breakdown.md
            PLANNED_STORIES=""
            if [ -f "$EPIC_DIR/epic-breakdown.md" ]; then
              # Look for story IDs in markdown (S001, S002, story-001, etc.)
              PLANNED_STORIES=$(grep -oE '(S[0-9]{3}|story-[0-9]{3})' "$EPIC_DIR/epic-breakdown.md" 2>/dev/null | sort -u | tr '\n' ' ' || true)
            fi
            
            STORIES_DIR="$EPIC_DIR/stories"
            mkdir -p "$STORIES_DIR" 2>/dev/null || true
            
            # Process all planned stories (from breakdown + existing directories)
            ALL_STORIES=""
            
            # Add stories from epic-breakdown.md
            for STORY_ID in $PLANNED_STORIES; do
              # Normalize to full format (S001 -> S001-name or keep as-is)
              if [[ "$STORY_ID" =~ ^S([0-9]{3})$ ]]; then
                # Check if a full-name directory exists
                FULL_DIR=$(ls -d "$STORIES_DIR/$STORY_ID"-* 2>/dev/null | head -1 || echo "")
                if [ -n "$FULL_DIR" ]; then
                  STORY_ID=$(basename "$FULL_DIR")
                fi
              fi
              ALL_STORIES="$ALL_STORIES $STORY_ID"
            done
            
            # Add stories from existing directories (already in full format)
            for STORY_DIR in $(ls -d "$STORIES_DIR"/*/ 2>/dev/null); do
              STORY_ID=$(basename "$STORY_DIR")
              ALL_STORIES="$ALL_STORIES $STORY_ID"
            done
            
            # Deduplicate and sort (now should properly match)
            ALL_STORIES=$(echo "$ALL_STORIES" | tr ' ' '\n' | grep -v '^$' | sort -u -V | tr '\n' ' ')
            
            # Process each story
            for STORY_ID in $ALL_STORIES; do
              [ -z "$STORY_ID" ] && continue
              
              # Normalize story name (S001 -> story-001 if that's what exists on disk)
              STORY_DIR="$STORIES_DIR/$STORY_ID"
              if [ ! -d "$STORY_DIR" ]; then
                # Try alternative format
                if [[ "$STORY_ID" =~ ^S([0-9]{3})$ ]]; then
                  ALT_ID="story-${BASH_REMATCH[1]}"
                  [ -d "$STORIES_DIR/$ALT_ID" ] && STORY_DIR="$STORIES_DIR/$ALT_ID" && STORY_ID="$ALT_ID"
                elif [[ "$STORY_ID" =~ ^story-([0-9]{3})$ ]]; then
                  ALT_ID="S${BASH_REMATCH[1]}"
                  [ -d "$STORIES_DIR/$ALT_ID" ] && STORY_DIR="$STORIES_DIR/$ALT_ID" && STORY_ID="$ALT_ID"
                fi
              fi
              
              STORY_NAME="$STORY_ID"
              
              # Skip if story is already complete (has validation report or retrospective)
              if [ -d "$STORY_DIR" ]; then
                if [ -f "$STORY_DIR/validation-report.md" ] || [ -f "$STORY_DIR/story-retro.md" ]; then
                  echo "  Skipping $STORY_NAME (already completed)"
                  continue
                fi
              fi
              
              EXISTING=$(gh issue list --label "speck:story" --search "in:title $STORY_NAME" --state open --json number --jq 'length' 2>/dev/null || echo "0")
              if [ "$EXISTING" -gt "0" ]; then
                echo "  Skipping $STORY_NAME (issue already exists)"
                continue
              fi
              
              if echo "$MERGED_PRS" | grep -q "$STORY_NAME"; then
                echo "  Skipping $STORY_NAME (PR already merged)"
                continue
              fi
              
              BLOCKED=false
              BLOCKING=""
              if [ -d "$STORY_DIR" ] && [ -f "$STORY_DIR/tasks.md" ]; then
                DEPS=$(sed -n '/^---$/,/^---$/p' "$STORY_DIR/tasks.md" | grep "depends_on:" | sed 's/depends_on://' | tr -d '[],' || true)
                for DEP in $DEPS; do
                  DEP=$(echo "$DEP" | tr -d ' "')
                  [ -z "$DEP" ] && continue
                  if ! echo "$MERGED_PRS" | grep -q "$DEP"; then
                    BLOCKED=true
                    BLOCKING="$BLOCKING $DEP"
                  fi
                done
              fi
              
              if [ -d "$STORY_DIR" ] && [ -f "$STORY_DIR/tasks.md" ]; then
                START_CMD="story-implement"
              elif [ -d "$STORY_DIR" ] && [ -f "$STORY_DIR/plan.md" ]; then
                START_CMD="story-tasks"
              elif [ -d "$STORY_DIR" ] && [ -f "$STORY_DIR/spec.md" ]; then
                START_CMD="story-clarify"
              else
                START_CMD="story-specify"
              fi
              
              TITLE=$([ -d "$STORY_DIR" ] && grep -m1 "^# " "$STORY_DIR/spec.md" 2>/dev/null | sed 's/^# //' || echo "$STORY_NAME")
              
              {
                echo "## Speck Story: $TITLE"
                echo ""
                echo "**Path**: \`$STORY_DIR\`"
                echo "**Start At**: \`$START_CMD\`"
                echo ""
                echo "@copilot Complete this story:"
                echo ""
                echo "1. Read \`AGENTS.md\` for the Speck methodology"
                echo "2. Navigate to \`$STORY_DIR\`"
                echo "3. Execute commands from \`.cursor/commands/\` starting at \`$START_CMD\`"
                echo "4. Create PR when implementation complete"
                echo ""
                echo "**Note**: Validation and retrospective are handled by separate workflows after PR creation."
                
                if [ "$BLOCKED" = true ]; then
                  echo ""
                  echo "---"
                  echo "âš ï¸ **BLOCKED** - Waiting for:$BLOCKING"
                fi
              } > /tmp/issue_body.md
              
              if [ "$BLOCKED" = true ]; then
                LABEL="speck:story,automated,speck:blocked"
              else
                LABEL="speck:story,automated,speck:queued"
              fi
              
              gh issue create \
                --title "ðŸ¤– [Speck] $STORY_NAME" \
                --body-file /tmp/issue_body.md \
                --label "$LABEL"
              
              echo "  Created: $STORY_NAME ($([ "$BLOCKED" = true ] && echo 'BLOCKED' || echo 'QUEUED'))"
            done
          done

  unblock-dependents:
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    
    steps:
      - name: Unblock dependent stories
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          STORY_NAME=$(echo "$PR_TITLE" | sed 's/.*\[Speck\] //' | head -1)
          echo "Story merged: $STORY_NAME"
          
          BLOCKED_ISSUES=$(gh issue list --label "speck:blocked" --json number,body --jq '.[] | @base64' 2>/dev/null || true)
          
          for ISSUE_B64 in $BLOCKED_ISSUES; do
            ISSUE=$(echo "$ISSUE_B64" | base64 -d)
            ISSUE_NUM=$(echo "$ISSUE" | jq -r '.number')
            ISSUE_BODY=$(echo "$ISSUE" | jq -r '.body')
            
            if echo "$ISSUE_BODY" | grep -q "$STORY_NAME"; then
              echo "Unblocking issue #$ISSUE_NUM"
              gh issue edit "$ISSUE_NUM" --remove-label "speck:blocked" --add-label "speck:queued"
              gh issue comment "$ISSUE_NUM" --body "âœ… Dependency **$STORY_NAME** merged! This story is now queued."
            fi
          done

  assign-copilot:
    needs: [ensure-labels, orchestrate]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Assign queued stories (rate limited)
        env:
          GH_TOKEN: ${{ secrets.COPILOT_ASSIGNMENT_TOKEN || secrets.GITHUB_TOKEN }}
          MAX_CONCURRENT: ${{ env.MAX_CONCURRENT_COPILOT }}
          REPO: ${{ github.repository }}
        run: |
          # Check if we have the required token
          if [ -z "${{ secrets.COPILOT_ASSIGNMENT_TOKEN }}" ]; then
            echo "âš ï¸  WARNING: COPILOT_ASSIGNMENT_TOKEN not set!"
            echo "The default GITHUB_TOKEN cannot assign copilot-swe-agent[bot]."
            echo "Please create a PAT with 'repo' scope and add it as COPILOT_ASSIGNMENT_TOKEN secret."
            echo "See: .speck/README.md â†’ Autonomous Development â†’ Setup"
            exit 1
          fi
          
          IN_PROGRESS=$(gh issue list --label "speck:in-progress" --json number --jq 'length' 2>/dev/null || echo "0")
          echo "In progress: $IN_PROGRESS / $MAX_CONCURRENT"
          
          AVAILABLE=$((MAX_CONCURRENT - IN_PROGRESS))
          [ "$AVAILABLE" -le 0 ] && { echo "Rate limit reached"; exit 0; }
          
          QUEUED=$(gh issue list --label "speck:queued" --json number --jq '.[].number' | head -n "$AVAILABLE")
          
          for ISSUE_NUM in $QUEUED; do
            echo "Assigning Copilot to #$ISSUE_NUM"
            
            # Build JSON payload
            PAYLOAD=$(cat <<'EOFPAYLOAD'
          {
            "assignees": ["copilot-swe-agent[bot]"],
            "agent_assignment": {
              "target_repo": "REPO_PLACEHOLDER",
              "base_branch": "main",
              "custom_instructions": "",
              "custom_agent": "",
              "model": ""
            }
          }
          EOFPAYLOAD
          )
            
            # Replace placeholder with actual repo
            PAYLOAD=$(echo "$PAYLOAD" | sed "s|REPO_PLACEHOLDER|$REPO|g")
            
            # Use official REST API to assign copilot-swe-agent[bot]
            echo "$PAYLOAD" | gh api \
              --method POST \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/repos/$REPO/issues/$ISSUE_NUM/assignees" \
              --input -
            
            # Update label to in-progress
            gh issue edit "$ISSUE_NUM" --remove-label "speck:queued" --add-label "speck:in-progress"
            
            echo "  âœ“ Copilot assigned to #$ISSUE_NUM"
          done
