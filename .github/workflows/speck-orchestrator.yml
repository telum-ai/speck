# Speck Orchestrator
#
# Continuous orchestration of story work. Creates issues and assigns to Copilot.
# Runs on schedule, push, PR merge, or manual trigger.
#
# SCOPE: Commands up to story-implement (creates PR)
# HANDOFF: speck-validate-pr.yml handles validation, speck-retrospective.yml handles retro

name: Speck Orchestrator

on:
  # Continuous orchestration - check every 15 minutes
  schedule:
    - cron: '*/15 * * * *'
  
  # Trigger on spec changes
  push:
    paths:
      - 'specs/**/epic-breakdown.md'
      - 'specs/**/stories/**'
    branches:
      - main
      - develop
  
  # Manual trigger
  workflow_dispatch:
    inputs:
      epic_path:
        description: 'Epic path (or leave empty to scan all)'
        required: false
        type: string
  
  # Re-orchestrate after PR merges (unblock dependents)
  pull_request:
    types: [closed]
    branches:
      - main
      - develop

permissions:
  contents: read
  issues: write
  pull-requests: read

env:
  MAX_CONCURRENT_COPILOT: 3

jobs:
  ensure-labels:
    runs-on: ubuntu-latest
    steps:
      - name: Create Speck labels if missing
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
        run: |
          gh label create "speck:story" --color "0E8A16" --description "Speck story" --force --repo "$GH_REPO" || true
          gh label create "speck:blocked" --color "B60205" --description "Blocked by dependencies" --force --repo "$GH_REPO" || true
          gh label create "speck:queued" --color "C5DEF5" --description "Queued for Copilot" --force --repo "$GH_REPO" || true
          gh label create "speck:in-progress" --color "FBCA04" --description "Copilot working" --force --repo "$GH_REPO" || true
          gh label create "automated" --color "BFD4F2" --description "Created by automation" --force --repo "$GH_REPO" || true

  orchestrate:
    needs: ensure-labels
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Find stories and create issues
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          EPIC_PATH: ${{ inputs.epic_path || '' }}
          REPO: ${{ github.repository }}
        run: |
          if [ -n "$EPIC_PATH" ]; then
            EPICS="$EPIC_PATH"
          else
            # Sort epics by numeric ID (E000, E001, E002...)
            EPICS=$(find specs -name "epic-breakdown.md" -exec dirname {} \; 2>/dev/null | sort -t/ -k6 -V || true)
          fi
          
          MERGED_PRS=$(gh pr list --repo "$REPO" --state merged --limit 100 --json title --jq '.[].title' 2>/dev/null || true)
          
          for EPIC_DIR in $EPICS; do
            echo "Processing epic: $EPIC_DIR"
            
            # Get epic info
            EPIC_ID=$(basename "$EPIC_DIR")
            EPIC_NAME=$(grep -m1 "^# " "$EPIC_DIR/epic.md" 2>/dev/null | sed 's/^# //' || echo "$EPIC_ID")
            EPIC_CONTEXT=$(sed -n '/^## Overview/,/^##/p' "$EPIC_DIR/epic.md" 2>/dev/null | head -10 | tail -9 || echo "See epic.md for details")
            
            # Extract planned stories from epic-breakdown.md
            PLANNED_STORIES=""
            if [ -f "$EPIC_DIR/epic-breakdown.md" ]; then
              PLANNED_STORIES=$(grep -oE '(S[0-9]{3}|story-[0-9]{3})' "$EPIC_DIR/epic-breakdown.md" 2>/dev/null | sort -u | tr '\n' ' ' || true)
            fi
            
            STORIES_DIR="$EPIC_DIR/stories"
            mkdir -p "$STORIES_DIR" 2>/dev/null || true
            
            # Collect all stories (from breakdown + existing directories)
            ALL_STORIES=""
            
            for STORY_ID in $PLANNED_STORIES; do
              # Normalize: check if full directory exists
              if [[ "$STORY_ID" =~ ^S([0-9]{3})$ ]]; then
                FULL_DIR=$(ls -d "$STORIES_DIR/$STORY_ID"-* 2>/dev/null | head -1 || echo "")
                if [ -n "$FULL_DIR" ]; then
                  STORY_ID=$(basename "$FULL_DIR")
                fi
              fi
              ALL_STORIES="$ALL_STORIES $STORY_ID"
            done
            
            for STORY_DIR in $(ls -d "$STORIES_DIR"/*/ 2>/dev/null); do
              ALL_STORIES="$ALL_STORIES $(basename "$STORY_DIR")"
            done
            
            # Deduplicate and sort
            ALL_STORIES=$(echo "$ALL_STORIES" | tr ' ' '\n' | grep -v '^$' | sort -u -V | tr '\n' ' ')
            
            for STORY_ID in $ALL_STORIES; do
              [ -z "$STORY_ID" ] && continue
              
              STORY_DIR="$STORIES_DIR/$STORY_ID"
              
              # Skip completed stories
              if [ -d "$STORY_DIR" ]; then
                if [ -f "$STORY_DIR/validation-report.md" ] || [ -f "$STORY_DIR/story-retro.md" ]; then
                  echo "  Skipping $STORY_ID (completed)"
                  continue
                fi
              fi
              
              # Skip if issue already exists
              EXISTING=$(gh issue list --repo "$REPO" --label "speck:story" --search "in:title $STORY_ID" --state open --json number --jq 'length' 2>/dev/null || echo "0")
              if [ "$EXISTING" -gt "0" ]; then
                echo "  Skipping $STORY_ID (issue exists)"
                continue
              fi
              
              # Skip if PR already merged
              if echo "$MERGED_PRS" | grep -q "$STORY_ID"; then
                echo "  Skipping $STORY_ID (PR merged)"
                continue
              fi
              
              # Determine current phase based on existing files
              CURRENT_PHASE="unspecced"
              START_CMD="story-specify"
              
              if [ -d "$STORY_DIR" ]; then
                if [ -f "$STORY_DIR/tasks.md" ]; then
                  CURRENT_PHASE="tasked"
                  START_CMD="story-analyze"  # ALWAYS run analyze before implement
                elif [ -f "$STORY_DIR/plan.md" ]; then
                  CURRENT_PHASE="planned"
                  START_CMD="story-tasks"
                elif [ -f "$STORY_DIR/spec.md" ]; then
                  # Check if clarified (has acceptance criteria filled out)
                  if grep -q "## Acceptance Criteria" "$STORY_DIR/spec.md" 2>/dev/null; then
                    CURRENT_PHASE="clarified"
                    START_CMD="story-plan"
                  else
                    CURRENT_PHASE="specified"
                    START_CMD="story-clarify"
                  fi
                fi
              fi
              
              # Get story title
              TITLE=""
              if [ -f "$STORY_DIR/spec.md" ]; then
                TITLE=$(grep -m1 "^# " "$STORY_DIR/spec.md" 2>/dev/null | sed 's/^# //' || echo "")
              fi
              if [ -z "$TITLE" ]; then
                if [[ "$STORY_ID" =~ ^[Ss][0-9]{3}-(.+)$ ]]; then
                  TITLE=$(echo "${BASH_REMATCH[1]}" | tr '-' ' ' | sed 's/\b\(.\)/\u\1/g')
                else
                  TITLE="(needs spec)"
                fi
              fi
              
              # Check dependencies
              BLOCKED=false
              BLOCKING=""
              if [ -f "$STORY_DIR/tasks.md" ]; then
                DEPS=$(sed -n '/^---$/,/^---$/p' "$STORY_DIR/tasks.md" | grep "depends_on:" | sed 's/depends_on://' | tr -d '[],' || true)
                for DEP in $DEPS; do
                  DEP=$(echo "$DEP" | tr -d ' "')
                  [ -z "$DEP" ] && continue
                  if ! echo "$MERGED_PRS" | grep -q "$DEP"; then
                    BLOCKED=true
                    BLOCKING="$BLOCKING $DEP"
                  fi
                done
              fi
              
              # Build issue body (structured for Copilot to parse)
              cat > /tmp/issue_body.md << ISSUE_EOF
## Story: $TITLE

| Field | Value |
|-------|-------|
| **Epic** | $EPIC_ID |
| **Story** | $STORY_ID |
| **Phase** | $CURRENT_PHASE |
| **Start Command** | \`$START_CMD\` |

### Epic Context
$EPIC_CONTEXT

### Command Flow

Execute commands in order starting from \`$START_CMD\`:

| Step | Command | Required | Creates |
|------|---------|----------|---------|
| 1 | \`story-specify\` | ✅ | \`spec.md\` |
| 2 | \`story-clarify\` | ✅ | Updates \`spec.md\` |
| 3 | \`story-plan\` | ✅ | \`plan.md\`, \`data-model.md\` |
| 4 | \`story-tasks\` | ✅ | \`tasks.md\` |
| 5 | \`story-analyze\` | ⚠️ **REQUIRED** | Quality check |
| 6 | \`story-implement\` | ✅ | Code + PR |

**Optional commands** (include when applicable):
- \`story-outline\` - Complex tech decisions needing research
- \`story-scan\` - Extending existing codebase
- \`story-ui-spec\` - UI-heavy with multiple components

### Critical: Task Format

When creating \`tasks.md\`, use **EXACT** format:
\`\`\`markdown
- [ ] T001 Description of task
- [ ] T002 [P] Parallel task (different files)
- [ ] T003 Another task
\`\`\`

⚠️ **Validation will fail** if format differs!

ISSUE_EOF

              if [ "$BLOCKED" = true ]; then
                cat >> /tmp/issue_body.md << BLOCK_EOF

---
⚠️ **BLOCKED** - Waiting for:$BLOCKING

Do not start until dependencies merge.
BLOCK_EOF
              fi
              
              # Set labels
              if [ "$BLOCKED" = true ]; then
                LABEL="speck:story,automated,speck:blocked"
              else
                LABEL="speck:story,automated,speck:queued"
              fi
              
              # Create issue
              gh issue create \
                --repo "$REPO" \
                --title "[$EPIC_ID] $STORY_ID: $TITLE" \
                --body-file /tmp/issue_body.md \
                --label "$LABEL"
              
              echo "  Created: $STORY_ID ($CURRENT_PHASE -> $START_CMD) [$([ "$BLOCKED" = true ] && echo 'BLOCKED' || echo 'QUEUED')]"
            done
          done

  unblock-dependents:
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    
    steps:
      - name: Unblock dependent stories
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          REPO: ${{ github.repository }}
        run: |
          STORY_NAME=$(echo "$PR_TITLE" | grep -oE 'S[0-9]{3}[^ ]*' | head -1 || echo "")
          [ -z "$STORY_NAME" ] && exit 0
          
          echo "Story merged: $STORY_NAME"
          
          BLOCKED_ISSUES=$(gh issue list --repo "$REPO" --label "speck:blocked" --json number,body --jq '.[] | @base64' 2>/dev/null || true)
          
          for ISSUE_B64 in $BLOCKED_ISSUES; do
            ISSUE=$(echo "$ISSUE_B64" | base64 -d)
            ISSUE_NUM=$(echo "$ISSUE" | jq -r '.number')
            ISSUE_BODY=$(echo "$ISSUE" | jq -r '.body')
            
            if echo "$ISSUE_BODY" | grep -q "$STORY_NAME"; then
              echo "Unblocking issue #$ISSUE_NUM"
              gh issue edit "$ISSUE_NUM" --repo "$REPO" --remove-label "speck:blocked" --add-label "speck:queued"
              gh issue comment "$ISSUE_NUM" --repo "$REPO" --body "✅ Dependency **$STORY_NAME** merged! This story is now queued."
            fi
          done

  assign-copilot:
    needs: [ensure-labels, orchestrate]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Assign queued stories (rate limited)
        env:
          GH_TOKEN: ${{ secrets.COPILOT_ASSIGNMENT_TOKEN || secrets.GITHUB_TOKEN }}
          MAX_CONCURRENT: ${{ env.MAX_CONCURRENT_COPILOT }}
          REPO: ${{ github.repository }}
        run: |
          # Check if we have the required token
          if [ -z "${{ secrets.COPILOT_ASSIGNMENT_TOKEN }}" ]; then
            echo "⚠️  WARNING: COPILOT_ASSIGNMENT_TOKEN not set!"
            echo "The default GITHUB_TOKEN cannot assign copilot-swe-agent[bot]."
            echo "Please create a PAT with 'repo' scope and add it as COPILOT_ASSIGNMENT_TOKEN secret."
            echo "See: .speck/README.md → Autonomous Development → Setup"
            exit 1
          fi
          
          IN_PROGRESS=$(gh issue list --repo "$REPO" --label "speck:in-progress" --json number --jq 'length' 2>/dev/null || echo "0")
          echo "In progress: $IN_PROGRESS / $MAX_CONCURRENT"
          
          AVAILABLE=$((MAX_CONCURRENT - IN_PROGRESS))
          [ "$AVAILABLE" -le 0 ] && { echo "Rate limit reached"; exit 0; }
          
          # Get queued issues sorted by number (ascending) to respect epic-story ordering
          QUEUED=$(gh issue list --repo "$REPO" --label "speck:queued" --json number --jq 'sort_by(.number) | .[].number' | head -n "$AVAILABLE")
          
          for ISSUE_NUM in $QUEUED; do
            echo "Assigning Copilot to #$ISSUE_NUM"
            
            # Build JSON payload
            PAYLOAD=$(cat <<'EOFPAYLOAD'
          {
            "assignees": ["copilot-swe-agent[bot]"],
            "agent_assignment": {
              "target_repo": "REPO_PLACEHOLDER",
              "base_branch": "main",
              "custom_instructions": "",
              "custom_agent": "",
              "model": ""
            }
          }
          EOFPAYLOAD
          )
            
            # Replace placeholder with actual repo
            PAYLOAD=$(echo "$PAYLOAD" | sed "s|REPO_PLACEHOLDER|$REPO|g")
            
            # Use official REST API to assign copilot-swe-agent[bot]
            echo "$PAYLOAD" | gh api \
              --method POST \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/repos/$REPO/issues/$ISSUE_NUM/assignees" \
              --input -
            
            # Update label to in-progress
            gh issue edit "$ISSUE_NUM" --repo "$REPO" --remove-label "speck:queued" --add-label "speck:in-progress"
            
            echo "  ✓ Copilot assigned to #$ISSUE_NUM"
          done
